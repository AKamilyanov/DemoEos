# Тестовое задание (динамический расчет отклонений)

## Постановка
Имеется БД, в которой одна таблица:\
(СУБД любая, для примера приведен скрипт MS SQL Server)
```sh
CREATE TABLE [dbo].[Items](
	[ItemId] [uniqueidentifier] NOT NULL,
	[ParentId] [uniqueidentifier] NULL,
	[Title] [nvarchar](254) NOT NULL,
	[Value] [int] NOT NULL
	CONSTRAINT [PK_Items] PRIMARY KEY CLUSTERED ( [ItemId] ASC )
)
GO
ALTER TABLE [dbo].[Items]  WITH CHECK ADD  CONSTRAINT [FK_Items_Items_ParentId] FOREIGN KEY([ParentId]) REFERENCES [dbo].[Items] ([ItemId])
GO
```
В рамках выполнения тестового задания требуется:
1.	Создать БД, наполнить тестовыми данными
(1-2 тыс. записей)
2.	Разработать сервер приложений, предоставляющий метод REST API:
(предпочтительно .Net Core + EF)

Глагол: Get

1. Название: GetItems
2. Параметры
	1. pParentId - идентификатор родительского узла, может быть null
	2. pPageNum - номер страницы
	3. pPageSize - количество записей на странице.
    
Метод возвращает JSON, содержащий массив записей со следующими полями
1. ItemId
2. Title
3. MaxValue

Алгоритм работы метода:

Найти все записи ParentId=pParentId, отсортировать полученные записи по полю Title, выдать в итоговом наборе массив размером  pPageSize с позиции pPage*pPageSize.\
Поле MaxValue в результатах выдачи расчетное. Считается по следующему алгоритму: 
	максимальное значение среди собственного значения Value и значений дочерних элементов

Примечание:\
Алгоритм формирования результатов метода GetItems должен работать быстро при ожидаемом количестве записей в таблице Items ~500 тыс., максимальный уровень вложенности по дереву ~ 20. 
Содержимое таблицы Items меняется редко. Для целей оптимизации алгоритма допускается введение новых колонок/индексов/таблиц и т.д.

## Установка
1. git clone https://github.com/AKamilyanov/DemoEos.git 
2. Открыть файл Demo.sln 
3. Отредактировать настройки sql подключения в Demo.Api/appsettings.json. При необходимости, конфигурацию запуска в launchSettings.json
4. Выполнить build & run
5. Если всё прошло успешно, то, после генерации БД со случайными данными, по адресу вида http://localhost/swagger/ откроется описание api, через который можно отправлять запросы

При первом запуске создается база, накатывается миграция и будут сгенерированы рандомные данные, около 500 тыс. записей.\
Вставка через BulkInsert занимает от 20 сек до нескольких минут (зависит от производительности sql сервера, уровней вложенности и проч).\
Можно задавать новые правила генерации реализовывая интерфейс IGenerationRule. 

## Тесты
Тесты лежат в папке Tests, один проект на тесты Core и Data слоёв, один проект на тесты Api слоя

## Использовались
* Visual studio 2019
* Asp.net core 2.2 + EF core 2.2 (SqlServer Express)
* Onion (Hexagonal) architecture 
* xUnit + Moq
* Swagger
* NLog


##### Review & Contacts mailto:archic2@mail.ru
